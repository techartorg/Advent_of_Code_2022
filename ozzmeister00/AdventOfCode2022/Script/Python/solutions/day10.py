"""
Python day10
"""
import copy

from utils.solver import ProblemSolver


class CRT(object):
    """
    Object to make it a little easier to isolate the functionality of drawing and debugging
    a CRT
    """
    Sprite = [-1, 0, 1]

    def __init__(self, buffer):
        """
        :param list[int] buffer: buffer values at each cycle count to use to draw the screen
        """
        self.buffer = buffer
        self.cycleCounter = 1
        self.debug = False

    @property
    def pixelPosition(self):
        return (self.cycleCounter - 1) % 40  # the pixel position is only ever between 0 and 39

    @property
    def spritePosition(self):
        return self.buffer[self.cycleCounter]

    def debug_spritePosition(self, spritePosition):
        """
        print the debug string for sprite position to compare results with the
        info from AoC

        :param int spritePosition: current center position of the sprite

        :return str: the debug string of the form "Sprite Position: ###...."
        """
        outStr = 'Sprite position: '
        for i in range(1, 41):
            outStr += self.evaluatePixel(i, spritePosition)

        return outStr

    def evaluatePixel(self, cycle=None, spritePosition=None):
        """
        Returns the screen value given the current cycle and sprite position

        :param int cycle: the current cycle
        :param int spritePosition: where the sprite is based on the current buffer
        :return str: # for a hit, and . for a miss
        """
        # handy for debugging purposes, but if no values are passed into the kwargs,
        # use the cycle, pixel, and sprite positions from the CRT itself
        if not cycle:
            cycle = self.cycleCounter
            pixelPos = self.pixelPosition
        else:
            pixelPos = cycle - 1

        if not spritePosition:
            spritePosition = self.spritePosition

        for i in CRT.Sprite:
            spritePos = spritePosition + i
            if pixelPos == spritePos:
                return '#'

        return '.'

    def __str__(self):
        """
        Print out the sprite resulting from the buffer
        :return str:
        """
        outStr = ''

        for i in range(1, len(self.buffer)):
            self.cycleCounter = i

            # pixel position is automatically clamped from 0 to 39
            # any time pixel position is 0, we should add a newline
            if not self.pixelPosition:
                outStr += '\n'

            outStr += self.evaluatePixel()

        return outStr


class Commands(object):
    noop = 'noop'
    addx = 'addx'


class Day10Solver(ProblemSolver):
    def __init__(self):
        super(Day10Solver, self).__init__(10)

        self.testDataAnswersPartOne = [13140]
        self.testDataAnswersPartTwo = ['''
##..##..##..##..##..##..##..##..##..##..
###...###...###...###...###...###...###.
####....####....####....####....####....
#####.....#####.....#####.....#####.....
######......######......######......####
#######.......#######.......#######.....''']
        self.cycleTargets = [20, 60, 100, 140, 180, 220]

    def ProcessInput(self, data=None):
        """

        :param data:
        :returns: processed data for today's challenge
        """
        if not data:
            data = self.rawData

        processed = []
        for line in data.splitlines(keepends=False):
            if line == Commands.noop:
                processed.append((line, 0))
            else:
                command, value = line.split(' ')
                value = int(value)
                processed.append((command, value))

        return processed

    def fillBuffer(self, operations):
        """
        Fill a buffer will the register values during each cycle
        :param list[(str, int)] operations: the list of operations to fill the buffer
        :return list[int]: register values during each cycle
        """
        register = 1
        values = [register]

        for command, value in operations:
            values.append(register)
            if command == Commands.addx:
                values.append(register)
                register += value

        return values

    def SolvePartOne(self, data=None):
        """

        :param data:
        :returns: The solution to today's challenge
        """
        if not data:
            data = copy.deepcopy(self.processed)

        buffer = self.fillBuffer(data)

        cycleChecks = [buffer[i] * i for i in self.cycleTargets]

        return sum(cycleChecks)

    def SolvePartTwo(self, data=None):
        """
        Draw the display based on the buffer values
        :param list[(int, int)] data: the operations to perform

        :returns str: the string generated by drawing the CRT
        """
        if not data:
            data = copy.deepcopy(self.processed)

        buffer = self.fillBuffer(data)

        crt = CRT(buffer)

        # just print and return the crt as a string, because the drawing functionality is built into it there
        print(crt)
        return str(crt)


if __name__ == '__main__':
    day10 = Day10Solver()
    day10.Run()
